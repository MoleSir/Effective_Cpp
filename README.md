# Effective C++
Notes and Test Code of Effective C++

- 条款01：~
- 条款02：多使用 `const`；
- 条款03：
    - 仅常量性不同的成员函数也可以重载；
    - `mutable` 的作用；
- 条款04：初始化列表的顺序最好与成员声明对象一致；
- 条款05：~
- 条款06：~
- 条款07：为多态基类声明 virtual 析构函数；
- 条款08：别让异常逃离析构函数，要么直接退出程序，要么不处理异常；
- 条款09：~
- 条款10：~
- 条款11：在operator=中处理自我赋值，也要注意new时可能抛出的异常会导致的问题；
- 条款12：特别要注意子类的拷贝构造与赋值函数中也要处理好父类成员的赋值；
- 条款13：使用资源管理类；
- 条款14：使用 RAII 时候注意自我复制的问题，可以禁止或使用引用计数等技术；
- 条款15：
    - RAII 类会有方法返回其拥有的资源（指针）；
    - 或者提供类型转换的运算符重载（很离谱的一招）；
- 条款16：用 `new []` 创建的资源，如果不使用 `delete[]` 释放，可能就只调用了一个析构函数；
- 条款17：先得到指针，再把指针放入 RAII 管理；
- 条款18：好的接口应该容易被使用、促进正确使用、阻止用户错误使用；
- 条款19：设计class犹如设计type；
- 条款20：
    - 尽量使用 `reference` 传递类对象参数，这样可以：
        - 提高效率；
        - 防止 slicing （对象切割）问题（将子类的值类型传入基类的值类型）；
    - 对 STL 中的仿函数与迭代器用值类型，其他的类用 `reference` 类型；
- 条款21：别让函数返回临时变量的 `reference`（C++11右值引用可以解决很多问题）
- 条款22：将成员变量声明为private；
- 条款23：最好声明一个类外函数来执行一个类的多种操作，可以增强封装性、包裹弹性和机能拓展性，因为类外函数不可以访问类的私有成员；
- 条款24：如果需要为某个函数的所有参数（包括被 this 指针所指的能够隐喻参数）进行类型转换，需要使用一个类外函数；
- 条款25：
    - 当 std::swap 效率不高时，提供一个 swap 成员函数，并且确定其不抛出异常；
    - 如果提供了 member swap，也应该提供一个 non-member swap 来调用前者。并且对于 class(非 template)，应该特化 std::swap；
    - 调用 swap 时应该针对 std::swap 使用 using ，然后调用 swap 并且不加任何“命名空间修饰符”；
    - 不要尝试在 std 中添加新东西，但可以对其中的模板进行特化；
- 条款26：尽可能延后变量定义式的出现。这样做可增加程序的清晰度并完善程序效率；
- 条款27：C++ 提供了 4 种新式转型，但尽量少用；
- 条款28：返回对象内部的指针、引用可能造成空对象；
- 
